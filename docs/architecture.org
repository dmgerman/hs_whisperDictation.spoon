#+title: Architecture Documentation
#+author: WhisperDictation Development Team
#+date: 2025

* Overview

WhisperDictation has been refactored from a 1500-line "God Object" into a clean, modular architecture following SOLID principles. The codebase is now fully tested (227 tests) and easy to extend.

* Design Principles

** 1. Single Responsibility Principle

Each class has exactly one reason to change:
- =RecordingManager= - Manages recording lifecycle
- =TranscriptionManager= - Manages transcription jobs
- =ChunkAssembler= - Assembles chunks in order
- =EventBus= - Pub/sub communication
- Backends - Audio capture
- Methods - Audio transcription

** 2. Dependency Injection

All dependencies are injected via constructor:

#+begin_src lua
local manager = RecordingManager.new(backend, eventBus, config)
#+end_src

This enables:
- Easy testing with mocks
- Runtime configuration
- No global state

** 3. Interface Segregation

Clean contracts define expectations:

*IRecordingBackend:*

#+begin_src lua
function IRecordingBackend:startRecording(config) ‚Üí Promise
function IRecordingBackend:stopRecording() ‚Üí Promise
function IRecordingBackend:isRecording() ‚Üí boolean
function IRecordingBackend:validate() ‚Üí (boolean, string?)
function IRecordingBackend:getDisplayText(lang) ‚Üí string
#+end_src

*ITranscriptionMethod:*

#+begin_src lua
function ITranscriptionMethod:transcribe(audioFile, lang) ‚Üí Promise
function ITranscriptionMethod:validate() ‚Üí (boolean, string?)
function ITranscriptionMethod:getName() ‚Üí string
function ITranscriptionMethod:supportsLanguage(lang) ‚Üí boolean
#+end_src

** 4. Event-Driven Communication

Components communicate via EventBus (pub/sub):

#+begin_src lua
-- Publisher
eventBus:emit("recording:started", {lang = "en"})

-- Subscriber
eventBus:on("recording:started", function(data)
  print("Recording started:", data.lang)
end)
#+end_src

*Benefits:*
- Loose coupling
- Easy to add new listeners
- No circular dependencies

** 5. Promise-Based Async

All async operations use Promises:

#+begin_src lua
backend:startRecording(config)
  :andThen(function()
    print("Recording started")
  end)
  :catch(function(err)
    print("Error:", err)
  end)
#+end_src

*Benefits:*
- No callback hell
- Composable (chaining, Promise.all)
- Clear error propagation

* Component Architecture

** Core Infrastructure

*** EventBus

Lightweight pub/sub system.

*Usage:*

#+begin_src lua
local EventBus = require("lib.event_bus")
local bus = EventBus.new()

-- Subscribe
local unsubscribe = bus:on("event", function(data) end)

-- Publish
bus:emit("event", {key = "value"})

-- Unsubscribe
unsubscribe()
-- or
bus:off("event", listener)
#+end_src

*** Promise

A/+ Promise implementation for Lua.

*Usage:*

#+begin_src lua
local Promise = require("lib.promise")

-- Create
local p = Promise.new(function(resolve, reject)
  if success then
    resolve(result)
  else
    reject(error)
  end
end)

-- Chain
p:andThen(function(result)
  return processResult(result)
end):catch(function(err)
  print("Error:", err)
end)

-- Utilities
Promise.resolve(value)
Promise.reject(reason)
Promise.all({p1, p2, p3})
#+end_src

** Business Logic

*** ChunkAssembler

Collects transcription chunks and concatenates them in order.

*Responsibilities:*
- Track chunks (out-of-order safe)
- Detect when all chunks received
- Concatenate in correct order
- Emit final result

*Events:*
- Listens: =transcription:complete=
- Emits: =transcription:all_complete=

#+begin_src lua
local ChunkAssembler = require("core.chunk_assembler")
local assembler = ChunkAssembler.new(eventBus)

assembler:addChunk(1, "First chunk", "/tmp/chunk1.wav")
assembler:addChunk(2, "Second chunk", "/tmp/chunk2.wav")
assembler:recordingStopped()  -- Triggers finalization if all chunks received
#+end_src

*** RecordingManager

Manages recording lifecycle with state machine.

*States:* =idle= ‚Üí =recording= ‚Üí =stopping= ‚Üí =idle=

*Responsibilities:*
- Control recording backend
- Track recording state
- Emit lifecycle events
- Handle errors gracefully

*Events:*
- Emits: =recording:started=, =recording:stopped=, =recording:error=

#+begin_src lua
local RecordingManager = require("core.recording_manager")
local manager = RecordingManager.new(backend, eventBus, config)

manager:startRecording("en")
  :andThen(function()
    print("Recording started")
  end)
#+end_src

*** TranscriptionManager

Manages transcription job queue.

*Responsibilities:*
- Generate unique job IDs
- Track pending/completed/failed jobs
- Coordinate with transcription method
- Emit job events

*Events:*
- Emits: =transcription:started=, =transcription:complete=, =transcription:error=

#+begin_src lua
local TranscriptionManager = require("core.transcription_manager")
local manager = TranscriptionManager.new(method, eventBus, config)

manager:transcribe("/tmp/audio.wav", "en")
  :andThen(function(text)
    print("Transcribed:", text)
  end)
#+end_src

** Recording Backends

*** SoxBackend

Simple recording using =sox= command.

#+begin_src lua
local SoxBackend = require("backends.sox_backend")
local backend = SoxBackend.new(eventBus)

backend:startRecording({
  outputDir = "/tmp",
  filenamePrefix = "en",
  lang = "en",
  eventBus = eventBus,
  chunkDuration = 5,
})
#+end_src

*** StreamingBackend

Advanced streaming with Python server and Silero VAD.

#+begin_src lua
local StreamingBackend = require("backends.streaming_backend")
local backend = StreamingBackend.new(eventBus, {
  pythonExecutable = "python3",
  serverScript = "whisper_stream.py",
  tcpPort = 12341,
  silenceThreshold = 2.0,
  minChunkDuration = 3.0,
  maxChunkDuration = 600.0,
})
#+end_src

*Architecture:*

#+begin_example
Lua (StreamingBackend)
  ‚Üï TCP Socket (JSON)
Python (whisper_stream.py)
  ‚îú‚îÄ sounddevice (audio capture)
  ‚îú‚îÄ Silero VAD (speech detection)
  ‚îî‚îÄ Chunk generation
#+end_example

** Transcription Methods

*** WhisperMethod (whisper.cpp)

#+begin_src lua
local WhisperMethod = require("methods.whisper_method")
local method = WhisperMethod.new({
  modelPath = "/usr/local/whisper/ggml-large-v3.bin",
  executable = "whisper-cpp"
})
#+end_src

*** WhisperKitMethod (Apple Silicon)

#+begin_src lua
local WhisperKitMethod = require("methods.whisperkit_method")
local method = WhisperKitMethod.new({
  executable = "whisperkit-cli",
  model = "large-v3"
})
#+end_src

*** WhisperServerMethod (HTTP Server)

#+begin_src lua
local WhisperServerMethod = require("methods.whisper_server_method")
local method = WhisperServerMethod.new({
  host = "127.0.0.1",
  port = 8080,
  curlCmd = "curl"
})
#+end_src

*** GroqMethod (Cloud API)

#+begin_src lua
local GroqMethod = require("methods.groq_method")
local method = GroqMethod.new({
  apiKey = "gsk_...",
  model = "whisper-large-v3",
  timeout = 30
})
#+end_src

** Main Orchestrator

*** WhisperDictation (v2)

Coordinates all components.

#+begin_src lua
local WhisperDictation = require("whisper_dictation_v2")

local wd = WhisperDictation.new({
  backend = backend,        -- IRecordingBackend
  method = method,          -- ITranscriptionMethod
  eventBus = eventBus,      -- EventBus (optional)
  tempDir = "/tmp/whisper", -- string
  defaultLang = "en",       -- string
})

-- Simple toggle
wd:toggleRecording()
wd:toggleRecording("ja")

-- With callback
wd:toggleRecordingWithCallback("en", function(text)
  print(text)
end)

-- Status
local status = wd:getStatus()
#+end_src

*** WhisperDictation (v1 Compat)

Backward-compatible wrapper.

#+begin_src lua
local WhisperDictationV1 = require("whisper_dictation_v1_compat")

local wd = WhisperDictationV1.new({...})

-- Old API works
wd:toggleTranscribe(nil)  -- Clipboard
wd:toggleTranscribe(function(text) end)  -- Callback
#+end_src

* Event Flow

** Recording Start

#+begin_example
User: Press hotkey
  ‚Üì
WhisperDictation:toggleRecording()
  ‚Üì
RecordingManager:startRecording()
  ‚Üì
Backend:startRecording()
  ‚Üì
[emit] recording:started
  ‚Üì
Update UI
#+end_example

** Chunk Ready (Streaming)

#+begin_example
Python Server: Chunk ready
  ‚Üì
[TCP] chunk_ready event
  ‚Üì
StreamingBackend:_handleServerEvent()
  ‚Üì
[emit] audio:chunk_ready
  ‚Üì
WhisperDictation (listening)
  ‚Üì
TranscriptionManager:transcribe()
  ‚Üì
[emit] transcription:started
  ‚Üì
Method:transcribe()
  ‚Üì
[emit] transcription:complete
  ‚Üì
ChunkAssembler:addChunk()
#+end_example

** Recording Stop

#+begin_example
User: Press hotkey
  ‚Üì
WhisperDictation:toggleRecording()
  ‚Üì
RecordingManager:stopRecording()
  ‚Üì
Backend:stopRecording()
  ‚Üì
[emit] recording:stopped
  ‚Üì
ChunkAssembler:recordingStopped()
  ‚Üì
(if all chunks received)
[emit] transcription:all_complete
  ‚Üì
WhisperDictation:_handleFinalText()
  ‚Üì
Paste or copy to clipboard
#+end_example

* Testing Architecture

** Test Pyramid

- *70% Unit Tests* - Individual components in isolation
- *20% Integration Tests* - Component interactions
- *10% E2E Tests* - Full workflows

** Mock Strategy

All tests use mocks for external dependencies:

#+begin_src lua
-- Mock backend
local mockBackend = {
  startRecording = function() return Promise.resolve() end,
  stopRecording = function() return Promise.resolve() end,
  isRecording = function() return false end,
  -- ...
}

-- Mock method
local mockMethod = {
  transcribe = function(audio, lang)
    return Promise.resolve("Transcribed text")
  end,
  -- ...
}
#+end_src

** Running Tests

#+begin_src bash
cd tests
busted spec/unit/           # All tests
busted spec/unit/core/      # Core components
busted spec/unit/backends/  # Backends
busted spec/unit/methods/   # Methods
#+end_src

* Adding New Components

** New Recording Backend

1. *Implement IRecordingBackend:*

#+begin_src lua
local MyBackend = {}
MyBackend.__index = MyBackend

function MyBackend.new(eventBus, config)
  local self = setmetatable({}, MyBackend)
  self.eventBus = eventBus
  self.config = config
  return self
end

function MyBackend:startRecording(config)
  local Promise = require("lib.promise")
  return Promise.new(function(resolve, reject)
    -- Your implementation
    resolve()
  end)
end

function MyBackend:stopRecording()
  -- ...
end

function MyBackend:isRecording()
  return self.isRecordingFlag
end

function MyBackend:validate()
  return true, nil
end

function MyBackend:getDisplayText(lang)
  return "üéôÔ∏è " .. lang
end

function MyBackend:getName()
  return "my-backend"
end

return MyBackend
#+end_src

2. *Write Tests:*

#+begin_src lua
describe("MyBackend", function()
  local backend, eventBus

  before_each(function()
    eventBus = EventBus.new()
    backend = MyBackend.new(eventBus, {})
  end)

  it("starts recording", function()
    -- Test implementation
  end)
end)
#+end_src

3. *Use It:*

#+begin_src lua
local MyBackend = require("backends.my_backend")
local wd = WhisperDictation.new({
  backend = MyBackend.new(eventBus, {...}),
  -- ...
})
#+end_src

** New Transcription Method

Similar process - implement =ITranscriptionMethod= interface.

* Best Practices

** 1. Always Use Promises

#+begin_src lua
-- Good
function doAsync()
  return Promise.new(function(resolve, reject)
    -- async work
    resolve(result)
  end)
end

-- Bad (callback hell)
function doAsync(callback)
  someAsync(function(result)
    callback(result)
  end)
end
#+end_src

** 2. Emit Events for State Changes

#+begin_src lua
-- Good
function RecordingManager:startRecording()
  self.state = "recording"
  self.eventBus:emit("recording:started", {...})
end

-- Bad (tight coupling)
function RecordingManager:startRecording()
  self.state = "recording"
  self.ui:updateIndicator()  -- Don't call UI directly
end
#+end_src

** 3. Inject Dependencies

#+begin_src lua
-- Good
function Component.new(dependency1, dependency2)
  self.dep1 = dependency1
  self.dep2 = dependency2
end

-- Bad (global access)
function Component.new()
  self.dep1 = globalDep1  -- Hard to test
end
#+end_src

** 4. Test Everything

Every component should have comprehensive tests covering:
- Happy path
- Error cases
- Edge cases
- State transitions

* Performance Considerations

** EventBus

- O(n) emit (calls all listeners)
- Keep listeners lightweight
- Unsubscribe when done

** Promise Chaining

- Promises execute synchronously in our implementation
- No async/await overhead
- Chain efficiently

** Memory Management

- Lua has GC, but avoid leaks:
  - Unsubscribe from events
  - Clear large arrays when done
  - Don't hold references to old jobs indefinitely

* Migration Path

** Phase 1: Compatibility Layer (Current)

- Keep old =init.lua= as entry point
- Wrap new architecture with v1 compat
- Old API continues working

** Phase 2: Encourage v2 Adoption

- Document v2 API benefits
- Provide migration examples
- Keep v1 compat for backward compatibility

** Phase 3: Deprecation (Future)

- Mark v1 as deprecated
- Update docs to show v2 first
- Keep v1 compat indefinitely for existing users

* Future Enhancements

Possible additions:
- WebSocket backend for remote recording
- More transcription methods (AssemblyAI, Rev.ai)
- Audio preprocessing (noise reduction)
- Vocabulary/context injection
- Real-time streaming transcription
- Multi-speaker diarization

All can be added without breaking existing code thanks to clean architecture!
